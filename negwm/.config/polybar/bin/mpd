#!/usr/bin/python -u

""" MPD info printing daemon.

This daemon prints current MPD volume like `tail -f` echo server, so there is
no need to use busy waiting to extract information from it.

Usage:
    ./mpd

Suppoused to be used inside polybar.

Config example:

[module/mpd]
type = custom/script
exec = python -u $XDG_CONFIG_HOME/polybar/bin/mpd
tail = true

Created by :: Neg
email :: <serg.zorg@gmail.com>
github :: https://github.com/neg-serg?tab=repositories
year :: 2023

"""

import asyncio
import sys
import time


class polybar_mpd():
    addr, port = '::1', '6600'
    buf_size = 2048
    fg = '%{F#ffCFCFDB}'
    fg_dark = '%{F#aaCFCFDB}'
    hi_color = '%{F#395573}'
    wave = '%{T4} %{T-}'
    fg_end = "%{F-}"
    delim = '%{F#657491}―%{F}'

    def __init__(self, _):
        super().__init__()
        # command to wait for mixer or player events from MPD
        self.idle_player = "idle player\n"
        # command to get song status from MPD
        self.get_song_data_cmd = "currentsong\nstatus\n"
        self.main()

    def main(self):
        """ Mainloop starting here. """
        asyncio.run(self.current_song_loop())

    @staticmethod
    def pretty_printing(song_data):
        vol = song_data.get('volume', '')
        if vol and int(vol) == 0:
            fg = polybar_mpd.fg_dark
        else:
            fg = polybar_mpd.fg
        fg_end = polybar_mpd.fg_end
        artist = f"{fg}{song_data.get('Artist', '')}"
        title = f"{fg}{song_data.get('Title', '')}"
        t = song_data.get('time', '')
        lhs = f"{polybar_mpd.hi_color} {polybar_mpd.wave}{fg_end}"
        delim = f"{polybar_mpd.hi_color}/{fg_end}"
        if artist and title and t:
            duration = f'%{{T5}}{fg}{t[0].strip()}{delim}{fg}{t[1].strip()}%{{T-}}\n'
            sys.stdout.write(f'{lhs}{artist} {polybar_mpd.delim} {title} {duration}')

    @staticmethod
    def time_convert(n) -> str:
        return time.strftime(" %M:%S", time.gmtime(n)).replace(' 0', ' ')

    async def update_mpd_stat(self, reader, writer) -> dict:
        song_data = {}
        writer.write(self.get_song_data_cmd.encode(encoding='utf-8'))
        raw_song_data = await reader.read(polybar_mpd.buf_size)
        ret = raw_song_data.decode('utf-8').split('\n')
        for tok in ret:
            tok = tok.split(':', maxsplit=1)
            for t in ['Artist', 'Title', 'time', 'state', 'volume']:
                if tok[0] == t:
                    song_data[t] = tok[1].strip()
                    if tok[0] == 'time':
                        t = tok[1].split(':')
                        current_time = float(t[0].strip())
                        total_time = float(t[1].strip())
                        song_data['time'] = [
                            polybar_mpd.time_convert(current_time),
                            polybar_mpd.time_convert(total_time)
                        ]
        return song_data

    async def mpd_stat_at_start(self, reader, writer) -> bytes:
        data = await reader.read(self.buf_size)
        writer.write(self.get_song_data_cmd.encode(encoding='utf-8'))
        return data.startswith(b'OK')

    async def current_song_loop(self) -> None:
        """ Update MPD current song info and print it. """
        verbose = False
        try:
            reader, writer = await asyncio.open_connection(
                host=polybar_mpd.addr, port=polybar_mpd.port
            )
        except ConnectionRefusedError:
            if verbose:
                print(f'MPD: Cannot connect via [{polybar_mpd.addr, polybar_mpd.port}]')
            return
        if await self.mpd_stat_at_start(reader, writer):
            while True:
                song_data = await self.update_mpd_stat(reader, writer)
                if song_data.get('state', '') == 'play':
                    polybar_mpd.pretty_printing(song_data)
                else:
                    sys.stdout.write('\n')
                await asyncio.sleep(0.1)


if __name__ == '__main__':
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    try:
        polybar_mpd(loop)
    except KeyboardInterrupt:
        pass
