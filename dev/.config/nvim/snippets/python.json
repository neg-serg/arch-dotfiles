{
  "#!": {
    "prefix": "#!",
    "description": "Shebang header for python scripts",
    "body": [
      "#!/usr/bin/env python",
      "# encoding: utf-8",
      "$0"
    ],
    "luasnip": {
      "priority": -50
    }
  },
  "ifmain": {
    "prefix": "ifmain",
    "description": "ifmain",
    "body": [
      "if __name__ == '__main__':",
      "\t${1:main()}$0"
    ]
  },
  "contain": {
    "prefix": "contain",
    "description": "methods for emulating a container type",
    "body": [
      "def __len__(self):",
      "\t${1:pass}",
      "",
      "def __getitem__(self, key):",
      "\t${2:pass}",
      "",
      "def __setitem__(self, key, value):",
      "\t${3:pass}",
      "",
      "def __delitem__(self, key):",
      "\t${4:pass}",
      "",
      "def __iter__(self):",
      "\t${5:pass}",
      "",
      "def __reversed__(self):",
      "\t${6:pass}",
      "",
      "def __contains__(self, item):",
      "\t${7:pass}"
    ]
  },
  "context": {
    "prefix": "context",
    "description": "context manager methods",
    "body": [
      "def __enter__(self):",
      "\t${1:pass}",
      "",
      "def __exit__(self, exc_type, exc_value, traceback):",
      "\t${2:pass}"
    ]
  },
  "attr": {
    "prefix": "attr",
    "description": "methods for customizing attribute access",
    "body": [
      "def __getattr__(self, name):",
      "\t${1:pass}",
      "",
      "def __setattr__(self, name, value):",
      "\t${2:pass}",
      "",
      "def __delattr__(self, name):",
      "\t${3:pass}"
    ]
  },
  "desc": {
    "prefix": "desc",
    "description": "methods implementing descriptors",
    "body": [
      "def __get__(self, instance, owner):",
      "\t${1:pass}",
      "",
      "def __set__(self, instance, value):",
      "\t${2:pass}",
      "",
      "def __delete__(self, instance):",
      "\t${3:pass}"
    ]
  },
  "cmp": {
    "prefix": "cmp",
    "description": "methods implementing rich comparison",
    "body": [
      "def __eq__(self, other):",
      "\t${1:pass}",
      "",
      "def __ne__(self, other):",
      "\t${2:pass}",
      "",
      "def __lt__(self, other):",
      "\t${3:pass}",
      "",
      "def __le__(self, other):",
      "\t${4:pass}",
      "",
      "def __gt__(self, other):",
      "\t${5:pass}",
      "",
      "def __ge__(self, other):",
      "\t${6:pass}",
      "",
      "def __cmp__(self, other):",
      "\t${7:pass}"
    ]
  },
  "repr": {
    "prefix": "repr",
    "description": "methods implementing string representation",
    "body": [
      "def __repr__(self):",
      "\t${1:pass}",
      "",
      "def __str__(self):",
      "\t${2:pass}",
      "",
      "def __unicode__(self):",
      "\t${3:pass}"
    ]
  },
  "numeric": {
    "prefix": "numeric",
    "description": "methods for emulating a numeric type",
    "body": [
      "def __add__(self, other):",
      "\t${1:pass}",
      "",
      "def __sub__(self, other):",
      "\t${2:pass}",
      "",
      "def __mul__(self, other):",
      "\t${3:pass}",
      "",
      "def __div__(self, other):",
      "\t${4:pass}",
      "",
      "def __truediv__(self, other):",
      "\t${5:pass}",
      "",
      "def __floordiv__(self, other):",
      "\t${6:pass}",
      "",
      "",
      "def __mod__(self, other):",
      "\t${7:pass}",
      "",
      "def __divmod__(self, other):",
      "\t${8:pass}",
      "",
      "def __pow__(self, other):",
      "\t${9:pass}",
      "",
      "",
      "def __lshift__(self, other):",
      "\t${10:pass}",
      "",
      "def __rshift__(self, other):",
      "\t${11:pass}",
      "",
      "def __and__(self, other):",
      "\t${12:pass}",
      "",
      "def __xor__(self, other):",
      "\t${13:pass}",
      "",
      "def __or__(self, other):",
      "\t${14:pass}",
      "",
      "",
      "def __neg__(self):",
      "\t${15:pass}",
      "",
      "def __pos__(self):",
      "\t${16:pass}",
      "",
      "def __abs__(self):",
      "\t${17:pass}",
      "",
      "def __invert__(self):",
      "\t${18:pass}",
      "",
      "",
      "def __complex__(self):",
      "\t${19:pass}",
      "",
      "def __int__(self):",
      "\t${20:pass}",
      "",
      "def __long__(self):",
      "\t${21:pass}",
      "",
      "def __float__(self):",
      "\t${22:pass}",
      "",
      "",
      "def __oct__(self):",
      "\t${22:pass}",
      "",
      "def __hex__(self):",
      "\t${23:pass}",
      "",
      "",
      "def __index__(self):",
      "\t${24:pass}",
      "",
      "def __coerce__(self, other):",
      "\t${25:pass}"
    ]
  },
  "roprop": {
    "prefix": "roprop",
    "description": "Read Only Property",
    "body": [
      "@property",
      "def ${1:name}(self):",
      "\t${2:return self._$1}$0"
    ]
  },
  "ife": {
    "prefix": "ife",
    "description": "If / Else",
    "body": [
      "if ${1:condition}:",
      "\t${2:pass}",
      "else:",
      "\t${3:pass}"
    ]
  },
  "ifee": {
    "prefix": "ifee",
    "description": "If / Elif / Else",
    "body": [
      "if ${1:condition}:",
      "\t${2:pass}",
      "elif ${3:condition}:",
      "\t${4:pass}",
      "else:",
      "\t${5:pass}"
    ]
  },
  "pdb": {
    "prefix": "pdb",
    "description": "Set PDB breakpoint",
    "body": "import pdb; pdb.set_trace()"
  },
  "ipdb": {
    "prefix": "ipdb",
    "description": "Set IPDB breakpoint",
    "body": "import ipdb; ipdb.set_trace()"
  },
  "pudb": {
    "prefix": "pudb",
    "description": "Set PUDB breakpoint",
    "body": "import pudb; pudb.set_trace()"
  },
  "ae": {
    "prefix": "ae",
    "description": "Assert equal",
    "body": "self.assertEqual(${1:first},${2:second})"
  },
  "at": {
    "prefix": "at",
    "description": "Assert True",
    "body": "self.assertTrue(${0:exp})"
  },
  "af": {
    "prefix": "af",
    "description": "Assert False",
    "body": "self.assertFalse(${1:expression})"
  },
  "aae": {
    "prefix": "aae",
    "description": "Assert almost equal",
    "body": "self.assertAlmostEqual(${1:first},${2:second})"
  },
  "an": {
    "prefix": "an",
    "description": "Assert is None",
    "body": "self.assertIsNone(${0:expression})"
  },
  "ann": {
    "prefix": "ann",
    "description": "Assert is not None",
    "body": "self.assertIsNotNone(${0:expression})"
  },
  "if": {
    "prefix": "if",
    "description": "if",
    "body": [
      "if $1:",
      "\t$2"
    ]
  },
  "?": {
    "prefix": "?",
    "description": "inline if",
    "body": "$1 if $2 else $3"
  },
  "while": {
    "prefix": "while",
    "description": "while",
    "body": [
      "while $1:",
      "\t$2"
    ]
  },
  "try": {
    "prefix": "try",
    "description": "try/except",
    "body": [
      "try:",
      "\t$1",
      "except $2${3: as $4}:",
      "\t$5"
    ]
  },
  "for": {
    "prefix": "for",
    "description": "for...in",
    "body": [
      "for $1 in $2:",
      "\t$3"
    ]
  },
  "def": {
    "prefix": "def",
    "description": "function",
    "body": [
      "def $1($2):",
      "\t$3"
    ]
  },
  "class": {
    "prefix": "class",
    "description": "class",
    "body": [
      "class $1${2:($3)}:",
      "\t$4"
    ]
  },
  "const": {
    "prefix": "const",
    "description": "class initializer",
    "body": [
      "def __init__(self, $1):",
      "\t$2"
    ]
  },
  "defm": {
    "prefix": "defm",
    "description": "method",
    "body": [
      "def $1(self, $2):",
      "\t$3"
    ]
  },
  "lamb": {
    "prefix": "lamb",
    "description": "lambda",
    "body": "lambda $1: $2"
  },
  "imp": {
    "prefix": "imp",
    "description": "import",
    "body": "import $1"
  },
  "from": {
    "prefix": "from",
    "description": "from...import",
    "body": "from $1 import $2"
  },
  "#!2": {
    "prefix": "#!2",
    "description": "shebang",
    "body": [
      "#!/usr/bin/env python",
      "# -*- coding: utf-8 -*-",
      "",
      "$1"
    ]
  }
}
