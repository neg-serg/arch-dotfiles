{
  "#!": {
    "prefix": "#!",
    "description": "Shebang header for python scripts",
    "body": [
      "#!/usr/bin/env python",
      "# encoding: utf-8",
      "$0"
    ],
    "luasnip": {
      "priority": -50
    }
  },
  "ifmain": {
    "prefix": "ifmain",
    "description": "ifmain",
    "body": [
      "if __name__ == '__main__':",
      "\t${1:main()}$0"
    ]
  },
  "contain": {
    "prefix": "contain",
    "description": "methods for emulating a container type",
    "body": [
      "def __len__(self):",
      "\t${1:pass}",
      "",
      "def __getitem__(self, key):",
      "\t${2:pass}",
      "",
      "def __setitem__(self, key, value):",
      "\t${3:pass}",
      "",
      "def __delitem__(self, key):",
      "\t${4:pass}",
      "",
      "def __iter__(self):",
      "\t${5:pass}",
      "",
      "def __reversed__(self):",
      "\t${6:pass}",
      "",
      "def __contains__(self, item):",
      "\t${7:pass}"
    ]
  },
  "context": {
    "prefix": "context",
    "description": "context manager methods",
    "body": [
      "def __enter__(self):",
      "\t${1:pass}",
      "",
      "def __exit__(self, exc_type, exc_value, traceback):",
      "\t${2:pass}"
    ]
  },
  "attr": {
    "prefix": "attr",
    "description": "methods for customizing attribute access",
    "body": [
      "def __getattr__(self, name):",
      "\t${1:pass}",
      "",
      "def __setattr__(self, name, value):",
      "\t${2:pass}",
      "",
      "def __delattr__(self, name):",
      "\t${3:pass}"
    ]
  },
  "desc": {
    "prefix": "desc",
    "description": "methods implementing descriptors",
    "body": [
      "def __get__(self, instance, owner):",
      "\t${1:pass}",
      "",
      "def __set__(self, instance, value):",
      "\t${2:pass}",
      "",
      "def __delete__(self, instance):",
      "\t${3:pass}"
    ]
  },
  "cmp": {
    "prefix": "cmp",
    "description": "methods implementing rich comparison",
    "body": [
      "def __eq__(self, other):",
      "\t${1:pass}",
      "",
      "def __ne__(self, other):",
      "\t${2:pass}",
      "",
      "def __lt__(self, other):",
      "\t${3:pass}",
      "",
      "def __le__(self, other):",
      "\t${4:pass}",
      "",
      "def __gt__(self, other):",
      "\t${5:pass}",
      "",
      "def __ge__(self, other):",
      "\t${6:pass}",
      "",
      "def __cmp__(self, other):",
      "\t${7:pass}"
    ]
  },
  "repr": {
    "prefix": "repr",
    "description": "methods implementing string representation",
    "body": [
      "def __repr__(self):",
      "\t${1:pass}",
      "",
      "def __str__(self):",
      "\t${2:pass}",
      "",
      "def __unicode__(self):",
      "\t${3:pass}"
    ]
  },
  "numeric": {
    "prefix": "numeric",
    "description": "methods for emulating a numeric type",
    "body": [
      "def __add__(self, other):",
      "\t${1:pass}",
      "",
      "def __sub__(self, other):",
      "\t${2:pass}",
      "",
      "def __mul__(self, other):",
      "\t${3:pass}",
      "",
      "def __div__(self, other):",
      "\t${4:pass}",
      "",
      "def __truediv__(self, other):",
      "\t${5:pass}",
      "",
      "def __floordiv__(self, other):",
      "\t${6:pass}",
      "",
      "",
      "def __mod__(self, other):",
      "\t${7:pass}",
      "",
      "def __divmod__(self, other):",
      "\t${8:pass}",
      "",
      "def __pow__(self, other):",
      "\t${9:pass}",
      "",
      "",
      "def __lshift__(self, other):",
      "\t${10:pass}",
      "",
      "def __rshift__(self, other):",
      "\t${11:pass}",
      "",
      "def __and__(self, other):",
      "\t${12:pass}",
      "",
      "def __xor__(self, other):",
      "\t${13:pass}",
      "",
      "def __or__(self, other):",
      "\t${14:pass}",
      "",
      "",
      "def __neg__(self):",
      "\t${15:pass}",
      "",
      "def __pos__(self):",
      "\t${16:pass}",
      "",
      "def __abs__(self):",
      "\t${17:pass}",
      "",
      "def __invert__(self):",
      "\t${18:pass}",
      "",
      "",
      "def __complex__(self):",
      "\t${19:pass}",
      "",
      "def __int__(self):",
      "\t${20:pass}",
      "",
      "def __long__(self):",
      "\t${21:pass}",
      "",
      "def __float__(self):",
      "\t${22:pass}",
      "",
      "",
      "def __oct__(self):",
      "\t${22:pass}",
      "",
      "def __hex__(self):",
      "\t${23:pass}",
      "",
      "",
      "def __index__(self):",
      "\t${24:pass}",
      "",
      "def __coerce__(self, other):",
      "\t${25:pass}"
    ]
  },
  "ife": {
    "prefix": "ife",
    "description": "If / Else",
    "body": [
      "if ${1:condition}:",
      "\t${2:pass}",
      "else:",
      "\t${3:pass}"
    ]
  },
  "ifee": {
    "prefix": "ifee",
    "description": "If / Elif / Else",
    "body": [
      "if ${1:condition}:",
      "\t${2:pass}",
      "elif ${3:condition}:",
      "\t${4:pass}",
      "else:",
      "\t${5:pass}"
    ]
  },
  "pdb": {
    "prefix": "pdb",
    "description": "Set PDB breakpoint",
    "body": "import pdb; pdb.set_trace()"
  },
  "pudb": {
    "prefix": "pudb",
    "description": "Set PUDB breakpoint",
    "body": "import pudb; pudb.set_trace()"
  },
  "ae": {
    "prefix": "ae",
    "description": "Assert equal",
    "body": "self.assertEqual(${1:first},${2:second})"
  },
  "at": {
    "prefix": "at",
    "description": "Assert True",
    "body": "self.assertTrue(${0:exp})"
  },
  "af": {
    "prefix": "af",
    "description": "Assert False",
    "body": "self.assertFalse(${1:expression})"
  },
  "aae": {
    "prefix": "aae",
    "description": "Assert almost equal",
    "body": "self.assertAlmostEqual(${1:first},${2:second})"
  },
  "an": {
    "prefix": "an",
    "description": "Assert is None",
    "body": "self.assertIsNone(${0:expression})"
  },
  "ann": {
    "prefix": "ann",
    "description": "Assert is not None",
    "body": "self.assertIsNotNone(${0:expression})"
  },
  "if": {
    "prefix": "if",
    "description": "if",
    "body": [
      "if $1:",
      "\t$2"
    ]
  },
  "?": {
    "prefix": "?",
    "description": "inline if",
    "body": "$1 if $2 else $3"
  },
  "while": {
    "prefix": "while",
    "body": "while ${1:condition}:\n\t${2:pass}$0",
    "description": "Code snippet to create a while loop structure."
  },
  "while/else": {
    "prefix": "while/else",
    "body": ["while ${1:expression}:", "\t${2:pass}", "else:", "\t${3:pass}"],
    "description": "Code snippet for a while loop with else"
  },
  "try:except:": {
    "prefix": "try",
    "body": "try:\n\t${1:pass}\nexcept ${2:Exception} as ${3:e}:\n\t${4:raise $3}$0",
    "description": "Code Snippet for a try and except blocks."
  },
  "try:except:else:finally": {
    "prefix": "tryef",
    "body": "try:\n\t${1:pass}\nexcept${2: ${3:Exception} as ${4:e}}:\n\t${5:raise}\nelse:\n\t${6:pass}\nfinally:\n\t${7:pass}$0",
    "description": "Code Snippet for a try/except/finally with else statement."
  },
  "try:except:else": {
    "prefix": "trye",
    "body": "try:\n\t${1:pass}\nexcept ${2:Exception} as ${3:e}:\n\t${4:raise $3}\nelse:\n\t${5:pass}$0",
    "description": "Code Snippet for a try/except with else statement."
  },
  "try:except:finally": {
    "prefix": "tryf",
    "body": "try:\n\t${1:pass}\nexcept ${2:Exception} as ${3:e}:\n\t${4:raise $3}\nfinally:\n\t${5:pass}$0",
    "description": "Code Snippet for a try/except/finally."
  },
  "with": {
    "prefix": "with",
    "body": ["with ${1:expression} as ${2:target}:", "\t${3:pass}"],
    "description": "Code snippet for a with statement"
  },
  "for": {
      "prefix": "for",
      "body": "for ${1:value} in ${2:iterable}:\n\t${3:pass}$0",
      "description": "Code snippet to create a for loop structure."
  },
  "for/else": {
      "prefix": "for/else",
      "body": [
          "for ${1:target_list} in ${2:expression_list}:",
          "\t${3:pass}",
          "else:",
          "\t${4:pass}"
      ],
      "description": "Code snippet for a for loop with else"
  },
  "def": {
    "prefix": "def",
    "description": "function",
    "body": [
      "def $1($2):",
      "\t$3"
    ]
  },
  "class": {
      "prefix": "class",
      "body": ["class ${1:classname}(${2:object}):", "\t${3:pass}"],
      "description": "Code snippet for a class definition"
  },
  "const": {
    "prefix": "const",
    "description": "class initializer",
    "body": [
      "def __init__(self, $1):",
      "\t$2"
    ]
  },
  "New class": {
      "prefix": "classi",
      "body": "class ${1:ClassName}(${2:object}):\n\t\"\"\"${3:docstring for $1.}\"\"\"\n\tdef __init__(self, ${4:arg}):\n\t\t${5:super($1, self).__init__()}\n\t\tself.arg = arg\n\t\t$0",
      "description": "Code snippet for a class definition."
  },
  "New method": {
      "prefix": "defs",
      "body": "def ${1:mname}(self, ${2:arg}):\n\t${3:pass}$0",
      "description": "Code snippet for a class method definition."
  },
  "New function": {
      "prefix": "def",
      "body": "def ${1:fname}(${2:arg}):\n\t${3:pass}$0",
      "description": "Code snippet for function definition."
  },
  "New async function": {
      "prefix": "adef",
      "body": "async def ${1:fname}(${2:arg}):\n\t${3:pass}$0",
      "description": "Code snippet for async function definition."
  },
  "lamb": {
    "prefix": "lamb",
    "description": "lambda",
    "body": "lambda $1: $2"
  },
  "imp": {
    "prefix": "im",
    "description": "import",
    "body": "import ${1:package/module}$0",
    "description": "Import a package or module"
  },
  "from ... import ...": {
      "prefix": "fim",
      "body": "from ${1:package/module} import ${2:names}$0",
      "description": "Import statement that allows individual objects from the module to be imported directly into the callerâ€™s symbol table."
  },
  "self": {
    "prefix": ".",
    "body": "self.$0",
    "description": "Shortend snippet to reference the self property in an object."
  },
  "__magic__": {
    "prefix": "__",
    "body": "__${1:init}__$0",
    "description": "Code snippet to create magic methods."
  },
  "#!2": {
    "prefix": "#!2",
    "description": "shebang",
    "body": [
      "#!/usr/bin/env python",
      "# -*- coding: utf-8 -*-",
      "",
      "$1"
    ]
  },
  "List comprehension": {
        "prefix": "lc",
        "body": "[${1:value} for ${2:value} in ${3:iterable}]$0",
        "description" : "List comprehension for creating a list based on existing lists."
    },
    "List comprehension if else": {
        "prefix": "lcie",
        "body": "[${1:value} if ${2:condition} else ${3:condition} for ${4:value} in ${5:iterable}]$0", 
        "description" : "List comprehension for creating a list based on existing lists, with conditional if-else statement."
    },
    "List comprehension if filter": {
        "prefix": "lci",
        "body": "[${1:value} for ${2:value} in ${3:iterable} if ${4:condition}$0]", 
        "description" : "List comprehension for creating a list based on existing lists, with conditional if statement."
    },
    "Dictionary comprehension": {
        "prefix": "dc",
        "body": "{${1:key}: ${2:value} for ${3:key}, ${4:value} in ${5:iterable}}$0", 
        "description" : "Handy and faster way to create dictories based on existing dictionaries."
    },
    "Dictionary comprehension if filter": {
        "prefix": "dci",
        "body": "{${1:key}: ${2:value} for ${3:key}, ${4:value} in ${5:iterable} if ${6:condition}}$0", 
        "description" : "Handy and faster way to create dictories based on existing dictionaries, with conditional if statement."
    },
    "Set comprehension": {
        "prefix": "sc",
        "body": "{${1:value} for ${2:value} in ${3:iterable}}$0", 
        "description" : "Create a set based on existing iterables."
    },
    "Set Comprehension if filter": {
        "prefix": "sci",
        "body": "{${1:value} for ${2:value} in ${3:iterable} if ${4:condition}}$0", 
        "description" : "Create a set based on existing iterables, with condition if statement."
    },
    "Generator comprehension": {
        "prefix": "gc",
        "body": "(${1:key} for ${2:value} in ${3:iterable})$0", 
        "description" : "Create a generator based on existing iterables."
    },
    "Generator comprehension if filter": {
        "prefix": "gci",
        "body": "(${1:key} for ${2:value} in ${3:iterable} if ${4:condition})$0", 
        "description" : "Create a generator based on existing iterables, with condition if statement."
    }
}
