#!/bin/dash
cache="/tmp"
file1="$cache/sxiv1.$$"
file2="$cache/sxiv2.$$"
tmp_imgur="$cache/sxiv_imgur.$$"
tmp_wall="$cache/wall_sxiv.$$"
z_data_file="$XDG_DATA_HOME/sxiv_do.data"
last_action="$XDG_DATA_HOME/sxiv_do.last"

trash_dir="$HOME/trash/1st-level/pic"
rofi_cmd="rofi -dmenu -sort -matching fuzzy -no-plugins -no-only-match -theme sxiv -custom"

resolve_file() {
    if  [ ! -L "$1" ] && [ -f "$1" ]; then
        echo $(readlink -f "$1")
    elif [ -L "$1" ]; then
        print "$(cd $(dirname "$1") && pwd -P)/$(basename "$1")"
    else
        echo "$1"
    fi
}

rotate() {
    degree="$1"
    while read file; do
        case "$(file -b -i "$file")" in
        image/jpeg*) 
            jpegtran -rotate "$degree" -copy all -outfile "$file" "$file"
        ;;
        *)
            mogrify  -rotate "$degree" "$file"
        ;;
        esac
    done
}

rename() {
    tee "$file1"
    dest=$(printf "%s" "$(basename "$fp")" | eval $(echo $rofi_cmd -p '"⟬$rem⟭ >> "'))
    [[ -n "$dest" ]] && \
        fp=$(< "$file1") && \
        mv "$fp" "$(dirname "$fp")/$dest"
    trap finish EXIT
}

proc() {
    cmd="$1";
    tee "$file1"
    if [ -z "$dest" ] ; then
        dest=$(_FASD_DATA="$XDG_DATA_HOME/sxiv_do.data" \
               fasd -tlR | sed 's:^'$HOME':~:' \
            | eval $rofi_cmd -p "\"⟬$cmd⟭ ❯> \"" \
            | sed 's:^~:'$HOME':')
    fi
    [ -z "$dest" ] && exit 0
    if [ -d "$dest" ]; then
        while read line; do
            eval $cmd \"$(resolve_file $line)\" $dest
        done < "$file1"
        _FASD_DATA="$z_data_file" fasd -RA "$dest"
        printf "%s\n" "$cmd "$dest"" > "$last_action"
    else
        _FASD_DATA="$z_data_file" fasd -D "$dest"
    fi
    trap finish EXIT
}

rep() {
    eval "$(cat "$last_action" | xargs)"
    trap finish EXIT
}

delete() {
    tee "$file1"
    [ -z "$trash_dir" ] || [ ! -d "$trash_dir" ] && exit 0
    while read line; do
        eval $(echo mv $(echo \"$(resolve_file $line)\") $trash_dir)
    done < "$file1"
    printf "%s\n" "mv "$trash_dir"" > "$last_action"
    trap finish EXIT
}

copy_name() {
    tee "$file2"
    fp=$(cat "$file2")
    fname="$(resolve_file $fp)"
    echo "$fname" | xsel -bi
    ~/bin/scripts/pic_notify "$fname"
    trap finish EXIT
}

imgur_it() {
    tee "$tmp_imgur"
    while read f; do
        fp="$(resolve_file $f)"
        ~/bin/img "$fp" | tee -a ~/tmp/imgur_output_ | xsel -i
        xsel -o | awk '/original/{print $2}' | xsel -i
    done < "$tmp_imgur"
    trap finish EXIT
}

wall() {
    action="$1"
    wallarg=""
    specarg=""
    case $action in
        c*) wallarg="-center" ;;
        t*) wallarg="-tile" ;;
        fi*) wallarg="-fill" ;;
        fu*) wallarg="-full" ;;
        mono) specarg="plus"
    esac
    >>"$tmp_wall"
    if [ -z $specarg ]; then
        while read wall; do
            hsetroot $wallarg "$wall" &
        done < "$tmp_wall"
    else
        while read wall; do
            convert "$wall" -colors 2 "$cache/__$(basename $wall)"
            hsetroot -full "$cache/__$(basename $wall)"
            rm "$cache/__$(basename $wall)"
        done < "$tmp_wall"
    fi
}

finish() {
    rm -f "$file1" "$file2" "$tmp_imgur"
}

case "$1" in
    "C-g") tr '\n' '\0' | xargs -0 gimp & ;;
    "C-comma") rotate 270 ;;
    "C-period") rotate 90 ;;
    "C-slash") rotate 180 ;;
    "C-less") rotate -90 ;;
    "C-d") delete ;;
    "v") proc mv ;;
    "C-c") proc cp ;;
    "C-r") rename ;;
    "r") rep ;;
    "c") copy_name ;;
    "C-q") wall "center" ;;
    "C-w") wall "fill" ;;
    "C-e") wall "full" ;;
    "C-r") wall "tile" ;;
    "C-t") wall "mono" ;;
    "C-i") imgur_it ;;
esac
